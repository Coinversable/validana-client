/**
 * @license
 * Copyright Coinversable B.V. All Rights Reserved.
 *
 * Use of this source code is governed by a AGPLv3-style license that can be
 * found in the LICENSE file at https://validana.io/license
 */

// tslint:disable-next-line:no-var-requires
const Buffer: typeof global.Buffer = require("buffer/").Buffer;
import { ECPair, networks, ECSignature } from "bitcoinjs-lib";
import { Crypto } from "./tools/crypto";

/** A public key. We use and accept compressed keys only. */
export class PublicKey {
	protected readonly key: ECPair;
	private address: string | undefined;

	/** Create a new public key from a buffer. Will throw an error if the buffer is not a valid public key. */
	constructor(publicKey: Buffer | ECPair) {
		if (publicKey instanceof Buffer) {
			this.key = ECPair.fromPublicKeyBuffer(publicKey, networks.bitcoin);
		} else if (publicKey instanceof ECPair) {
			this.key = publicKey;
		} else {
			throw new Error("Invalid type for public key");
		}
		if (!this.key.compressed) {
			throw new Error("Only compressed keys are supported.");
		}
	}

	/** Check if a public key is valid or not. We accept only compressed public keys. */
	public getPublicKey(): Buffer {
		return this.key.getPublicKeyBuffer();
	}

	/** Check if a public key is valid or not. We accept only compressed public keys. */
	public static isValidPublic(publicKey: Buffer): boolean {
		try {
			return ECPair.fromPublicKeyBuffer(publicKey, networks.bitcoin).compressed;
		} catch {
			return false;
		}
	}

	/** Check if an address is valid or not. Only prefix 0 is accepted. */
	public static isValidAddress(address: string): boolean {
		if (typeof address !== "string") {
			return false;
		}
		try {
			const decodedAddress = Crypto.base58ToBinary(address);
			const checksum = decodedAddress.slice(-4);
			return decodedAddress[0] === 0x00 && Crypto.hash256(decodedAddress.slice(0, -4)).slice(0, 4).equals(checksum);
		} catch {
			return false;
		}
	}

	/** Get the address of this public key. We use the address of the compressed key with prefix 0. */
	public getAddress(): string {
		if (this.address === undefined) {
			this.address = this.key.getAddress();
		}
		return this.address;
	}

	/** Verify a message and its signature against a public key. Will throw an error if any of the input values is not valid. */
	public static verify(publicKey: Buffer, hash: Buffer, signature: Buffer): boolean {
		return ECPair.fromPublicKeyBuffer(publicKey, networks.bitcoin).verify(
			hash,
			ECSignature.parseCompact(Buffer.concat([Crypto.uInt8ToBinary(27), signature])).signature
		);
	}
}

/**
 * A private key.
 * Technical info: Only the secp256k1 curve is supported, We use compressed
 * wif prefix 0x80 (same as bitcoin) by default, but accept all others.
 */
export class PrivateKey extends PublicKey {
	//Compressed is only used if public key is not given
	private constructor(privateKey: ECPair) {
		super(privateKey);
	}

	/** Generate a new random private key. An error will be thrown if no suitable random source is available. */
	public static generate(): PrivateKey {
		return new PrivateKey(ECPair.makeRandom({ compressed: true, network: networks.bitcoin }));
	}

	/** Check if a WIF is valid or not. Only compressed wifs with prefix 0x80 are accepted. */
	public static isValidWIF(wif: string): boolean {
		try {
			return ECPair.fromWIF(wif, networks.bitcoin).compressed;
		} catch (error) {
			return false;
		}
	}

	/**
	 * Get the wif of this private key.
	 * By default it will use the same format it was imported in.
	 * If it was generated by generate() this will be compressed with network prefix 0x80
	 */
	public toWIF(): string {
		return this.key.toWIF();
	}

	/** Turn a WIF into a private key. Throws an error if wif is not a valid private key. */
	public static fromWIF(wif: string): PrivateKey {
		const privateKey = ECPair.fromWIF(wif, networks.bitcoin);
		if (!privateKey.compressed) {
			throw new Error("Only compressed keys are supported.");
		}
		return new PrivateKey(privateKey);
	}

	/** Sign data with this private key. Returns the signature as 32 bytes r followed by 32 bytes s. */
	public sign(data: Buffer): Buffer {
		return this.key.sign(Crypto.hash256(data)).toCompact(0, false).slice(1);
	}
}